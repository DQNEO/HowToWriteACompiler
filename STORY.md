# 手順書

19 引き算、掛け算、割り算 に対応します。

18 二項式( ' 2 + 3 ' )をパース＆コンパイルできるようにします

17 単項式 ‘+1’, ‘-1’をパース＆コンパイルできるようにします

16 echo '-10' すなわち単項式をコンパイルできるようにしたい。
  parseUnaryExpr()を抽出します。

15 getToken()を実装します
 * トークンIndexという概念を導入します。
 * 今回はパーサを式パーサと呼ぶことにします。そのうち、単項式を読む処理をさらに切り出します。

14 generateExprを抽出します
* コード生成処理のうち、式をアセンブリに変換する部分をさらに切り出します

13 ParserとCodeGeneratorを分離します
* パーサという概念を導入します。
* パーサは、トークン列を読んで式に変換します。
* アセンブリ生成処理を別関数として切り出します。

11 「式」という概念を導入します。数値tokenを使って数値リテラル式というオブジェクトを作ります
* 最初のトークンを「数値リテラル」と解釈します
* (tokenizer をいったんグローバル変数に昇格します)


9 ;がまだエラーになる。;を 句読点トークンとして認識させます。
 これにより、echo -n ' 42 ;'をトークン列として認識できるようになる

8 tokenizerが空白文字を読み飛ばすようにします(トークンの区切りとみなす)
 → これにより、echo -n ' 42 ' がコンパイルできる。-nも省ける。 

7 Tokenizerを作ります。
 トークン列をデバグ表示します

6 Token構造体を導入
  42は “intリテラル” というトークン

5 getChar()導入

課題:これだけだと入力したソースコードをアセンブリに埋め込んでるだけ。
具体的:  ‘ 42 ; ‘を解釈できない。

* ‘  42  ; ‘ みたいな入力から42だけを取り出したい。
* さっき解説した３つの視点を思い出そう。トークン分割する必要がある。
* トークン分割するには、ソースコードを1文字ずつ解釈していく必要がある。
→　getChar()を導入

4 数値をハードコードする代わりに標準入力から受け取ります
3 コンパイラの実装をはじめます。まず、先程のアセンブリをGoからprintします。
  実行します
2 アセンブリを実行する手順を自動化します。

1 準備編です。まずアセンブリを書きます。
これをアセンブルして実行すると終了ステータスがこうなります。
